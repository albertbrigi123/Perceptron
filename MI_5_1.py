# -*- coding: utf-8 -*-
"""MI-5

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iiKAZeI6L2jVOKdKq4oDrxPptEpQ79br
"""

from numpy import array,random,dot,reshape,linspace
import matplotlib.pyplot as plt
import time
training_data = array([[1, 0, 0],
                       [1, 0, 1],
                       [1, 1, 0],
                       [1, 1, 1]])

result = array ([0, 0, 0, 1])

hardlim = lambda x: 0 if x < 0 else 1



def perceptron_learning(data, result):
  
  plt.ion()
  figure = plt.figure()
  figure.suptitle("Perceptron decision boundary")
  plt.grid()
  plt.xlim((-.5,1.5))
  plt.ylim((-.5,1.5))
  x = linspace(-5, 5, 20)

  lr = .01
  E = 1
  N, n = data.shape
  w = random.randn(n, 1)
  
  for i in range (0,N):
    if result[i] == 1:
        plt.scatter(data[i, 1], data[i, 2], c = 'red')
    else:
        plt.scatter(data[i, 1], data[i, 2], c = 'blue')

  a = [0, -w[0] / w[2]]
  c = [-w[0] / w[1], 0]
  m = (a[1] - a[0]) / (c[1] - c[0])
  line1,=plt.plot(x, x * m + a[1])

  while E != 0:
    
    E = 0
    for i in range (0,N):
      yi = hardlim(dot(data[i],w))
      ei = result[i] - yi
      errors.append(ei) 
      w = w + lr * ei * data[i].reshape(n, 1)
      E = E + ei ** 2
    a = [0, -w[0] / w[2]]
    c = [-w[0] / w[1], 0]
    m = (a[1] - a[0]) / (c[1] - c[0])
    line1.set_ydata(x * m + a[1])
    figure.canvas.draw()
    #time.sleep(.5)
    figure.canvas.flush_events()
    plt.figure(2)
    plt.ylim([-1,1]) 
    plt.plot(errors)
    
    

perceptron_learning(training_data,result)



